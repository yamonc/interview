# MySQL基础面试题

## 索引

### 什么是索引？

索引是一种特殊的文件（InnoDB数据表上的索引是表空间的一个组成部分），它包含着对数据表里所有记录的引用指针。

索引是一种数据结构。数据库索引是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树以及变种B+树。

更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。

### 索引的优缺点？

优点：

- 可以加快数据的检索速度，这也是创建索引的最主要的原因。
- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

缺点：

- 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增删改查的时候，索引需要动态的维护，会降低增删改的执行效率
- 空间方面：索引占用物理空间。

### 什么时候使用索引？

#### where

where查询的时候，如果对其指定了索引，那么查询比较快，如果没有添加索引的话，添加比较慢。

> 查看一条语句的执行情况：`explain select * from innodb where id>10`

如果在id上创建索引的话，查询比较快。

> 添加列语句：`alter table innodb add sex char(1)`
>
> 创建索引：`alter table innodb add index(sex)`

#### order by

当我们使用order by将查询结果按照某个字段排序的时候，如果该字段没有建立索引，那么执行计划将查询出来的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作很影响性能。

如果我们对排序字段建立索引的话，由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的话，那么只用取出索引表某个范围内的索引对应的数据，而不用像上述取出所有数据进行排序再返回某个范围内的数据。

#### join

对join语句匹配关系（on）涉及的字段创建索引能够提高效率。

#### 索引覆盖

如果要查询的字段都建立过索引，那么引擎会直接在索引表内查询数据，而不需要二次回表，这就叫索引覆盖。因此我们需要尽可能地在select后面只写必要的查询字段，增加索引覆盖的几率。

### 索引有哪几种类型？

1. 主键索引：数据列不允许重复，不允许为NULL，一个表只有一个主键。
2. 唯一索引：数据列不允许重复，允许为NULL，一个表允许多个列创建唯一索引。
3. 普通索引：基本的索引类型，没有唯一性的限制，允许为NULL值。
4. 全文索引：是目前搜索引擎使用的一种关键技术，对文本的内容进行分词、搜索。
5. 覆盖索引：查询列要被创建的索引覆盖，不必读取数据行。
6. 组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并。

索引的数据结构

索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。

B+的性质

1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。

2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。

4.）B+ 树中，数据对象的插入和删除仅在叶节点上进行。

5.）B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。

哈希索引

数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。

![image-20210901143534393](https://gitee.com/yamonc/blogImage/raw/master//img/blogImage/image-20210901143534393.png)

### 索引的基本原理

索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。

索引的原理很简单，就是把无序的数据变成有序的查询

1. 把创建了索引的列的内容进行排序
2. 对排序结果生成倒排表
3. 在倒排表内容上拼上数据地址链
4. 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据

### 索引的算法

B树

BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,>,>=,<,<=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量。

例如：如果一通配符开头，或者没有使用常量，则不会使用索引，例如： select * from user where name like '%jack';

Hash算法

Hash算法只能使用对等比较，例如=,<=>（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。

### 索引的设计原则

1. 适合索引的列是出现再where子句中的列，或者连接子句中指定的列。
2. 基数较小的类，索引效果较差，没有必要在此列建立索引。
3. 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能节省大量索引空间。
4. 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。

### 创建索引的原则

- 最左前缀匹配原则：组合索引非常重要的原则，MySQL会一致向右匹配直到遇到范围查询（>、<.between like)就停止匹配。
- 比较频繁作为查询条件的字段才会去创建索引
- 更新频繁字段不适合创建索引。
- 若是不能有效区分数据的列不适合做索引列（比如性别、男女未知最多也就三种情况，区别读太低了）
- 尽量地扩展索引，不要新增索引。
- 定义了外键的数据列一定要建立索引。
- 对于哪些查询中很少涉及的列，重复值比较多的列不要建立索引。
- 队医定义为text、image、bit的列不要建立索引。

TODO：最左匹配原则，创建索引的原则、为什么外键一定要创建索引、怎么扩展索引。

### 创建索引的三种方式

第一种：create table中创建索引。比如

```sql
create table user{
	id INT auto_increment PRIMARY KEY,
	first_name VARCHAR(16),
	last_name VARCHAR(16),
	id_card VARCHAR(18),
	information text,
	KEY name(first_name, last_name),
	FULLTEXT KEY(information),
	UNIQUE KEY(id_card)
}
```

第二种：使用alter table命令增加索引

```sql
alter table table_name add index index_name(column_list)
```

alter table可以创建普通索引、UNIQUE索引或者PRIMARY KEY索引。

其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。

索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。

第三种方式：使用CREATE INDEX命令创建

CREATE INDEX index_name ON table_name (column_list); 1 CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）

### 索引失效的情况

数据类型转化、使用函数、使用谓词计算比如（where id -1= 1）、存在null值（比如where id is null）、not（not <> in not exists）、like通配符

### 删除索引

根据索引名删除普通索引、唯一索引、全文索引：alter table 表名 drop KEY 索引名

删除主键索引：alter table 表名 drop primary key（因为主键只有一个）。但是主键一般都自增，这时候需要先取消自增，然后在删除。

### 创建索引的时候需要注意什么？

- 非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；
- 取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；
- 索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。

### 百万级别以上的数据怎么删除？

关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。

1. 所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）
2. 然后删除其中无用数据（此过程需要不到两分钟）
3. 删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。
4. 与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。

### 什么是前缀索引？

语法：index(filed(10)),使用字段值的前10个字符创建索引，默认是全部内容建立索引。

前提：前缀的标识度高，比如密码适合创建前缀索引，因为密码几乎各不相同。



### 什么是最左前缀原则？什么是最左匹配原则？

- 顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。
- 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
- =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

### B树和B+树的区别：

- 在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。
- B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。

#### 使用B树的好处

B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。

#### 使用B+树的好处

由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间

### hash索引和B+树有什么区别或者说优劣式呢？

Hash索引底层就是hash表，进行查找的时候，调用一次hash函数可以得到相应的键值，之后根据值的地址回表查询获得实际数据。

B+树底层实现是多层平衡查找树，对于每一次的查询都是从根节点出发，找到叶子结点可以获得所查键值，然后根据查询判断是否需要回表查询数据。

**不同：**

hash索引进行等值查询更快，但是无法进行范围查询。

> 因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。
>
> B+树的所有节点遵循左节点下于父节点，右节点大于父节点。天然支持范围

hash索引不支持使用索引排序。

hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理因为hash的不可预测。

hash索引任何时候都需要回表查询，而B+树可以在聚簇索引、覆盖索引的时候可以不回表。

hash虽然在等值上查询比较快，但是不稳定。原因是如果发生碰撞的话，效率比较低。b+更稳定。

### 数据库为什么使用B+树而不是B树？

- B树只适合随机检索，而B+树同时支持随机检索和顺序检索；
- B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；
- B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。
- B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。
- 增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。

### B+树在满足聚簇索引和覆盖索引为什么不用回表查询数据？

在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引

当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。

### 什么是聚簇索引？何时使用聚簇索引与非聚簇索引？

- 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
- 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因

澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值。

何时使用聚簇索引与非聚簇索引？

![image-20210901152009720](https://gitee.com/yamonc/blogImage/raw/master//img/blogImage/image-20210901152009720.png)

### 非聚簇索引一定要回表查询吗？

不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。

### 联合索引是什么？为什么需要注意联合索引中的顺序？

MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

具体原因为:

MySQL使用索引时需要索引有序，假设现在建立了"name，age，school"的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。

当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。

-----





[参考资料](https://zhuanlan.zhihu.com/p/370681806)

